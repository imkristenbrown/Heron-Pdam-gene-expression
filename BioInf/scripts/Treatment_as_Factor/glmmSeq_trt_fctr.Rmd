---
title: "glmmSeq_trt_fctr"
author: "Zoe Dellaert"
date: "3/8/2023"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This is a Rmd file analyzing our raw count data by the glmmSeq package as described in the [vignette](https://cran.r-project.org/web/packages/glmmSeq/vignettes/glmmSeq.html) and [manual](https://cran.r-project.org/web/packages/glmmSeq/glmmSeq.pdf).

```{r}
sessionInfo() #provides list of loaded packages and version of R. I still have version 4.1 for now.
```

First, download the glmmSeq package. I had to install qvalue using BiocManager as described in the [vignette](https://cran.r-project.org/web/packages/glmmSeq/vignettes/glmmSeq.html)

```{r install packages, eval=FALSE}
#if (!requireNamespace("BiocManager", quietly = TRUE))
    #install.packages("BiocManager")
    #BiocManager::install("qvalue"))

#install.packages("glmmSeq") #from CRAN
#devtools::install_github("myles-lewis/glmmSeq") # from github
```

Next, load the package 
  
```{r}
library(glmmSeq)
library(dplyr) #load dplyr, which is required to run this tutorial but not included in the vignette
library(kableExtra) #load kableExtra, which is also required to run this tutorial but not included in the vignette
sessionInfo()
```


and load in raw count data
```{r}
cts_raw <- read.csv("../../TagSeq_Output/HeronPdam_gene_count_matrix.csv") #load in data
rownames(cts_raw) <- cts_raw[,1]
cts_raw <- cts_raw[,-1]
head(cts_raw[,1:10])
```


```{r}
colnames(cts_raw)<-gsub("_[^_]+$", "",colnames(cts_raw))
colnames(cts_raw)<-gsub("_[^_]+$", "",colnames(cts_raw))
colnames(cts_raw)
```

Metadata from this dataset
```{r}
coldata <- read.csv("../../../RAnalysis/Data/RNA Submission Sample List metadata.csv")
coldata <- plyr::rename(coldata, c("Sample.Name"="Coral_ID"))
coldata$Colony <- gsub("A", "", coldata$Coral_ID)
coldata$Colony <- gsub("B", "", coldata$Colony)
coldata$Colony <- gsub("C", "", coldata$Colony)
coldata$Colony <- gsub("D", "", coldata$Colony)
coldata <- as.data.frame(coldata)
coldata$Origin <- factor(coldata$Origin)
coldata$Colony <- factor(coldata$Colony)
coldata$Treatment <- factor(coldata$Treatment)
head(coldata)
```

Data sanity checks:
```{r}
all(rownames(coldata$Coral_ID) %in% colnames(cts_raw))
all(rownames(coldata$Coral_ID) == colnames(cts_raw))
```

## Using filtered data instead of raw counts as input

```{r}
cts_filt<-cts_raw[rowSums(!as.matrix(cts_raw)) < ncol(cts_raw), ]#here we remove all genes that were not expressed in any of our samples- we are left with 24,333 genes.
```

```{r}
library(genefilter)
ffun<-filterfun(pOverA(0.25,10)) 
cts_filtpoa<- genefilter((cts_filt), ffun)
sum(cts_filtpoa)

cts_filtpoa <- cts_filt[cts_filtpoa,]
```

Data sanity checks:
```{r}
all(rownames(coldata$Coral_ID) %in% colnames(cts_filtpoa))
all(rownames(coldata$Coral_ID) == colnames(cts_filtpoa))
```


### Time to calculate dispersion!

"Using negative binomial models requires gene dispersion estimates to be made. This can be achieved in a number of ways. A common way to calculate this for gene i is to use the equation:

Dispersioni = (variancei - meani)/meani2

Starting with raw counts, so using [DESeq2](http://bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html), but could also import a normalized gene count matrix (i.e. transcripts per million) and calculate disperson manually as in the [vignette](https://cran.r-project.org/web/packages/glmmSeq/vignettes/glmmSeq.html).

```{r}
library(DESeq2)

dds_filt <- DESeqDataSetFromMatrix(countData = cts_filtpoa,
                              colData = coldata,
                              design = ~1) #this is what the glmmseq vignette says, cannot tell if we should put our formula in here yet or just calculate around the intercept.

# dds <- DESeqDataSetFromMatrix(countData = cts_raw,
#                               colData = coldata,
#                               design = ~ Treatment * Origin + (1 | Colony)) #ALTERNATIVE, but probably without the "1 | Colony" bit.

dds_filt <- DESeq(dds_filt)
dispersions_filt <- setNames(dispersions(dds_filt), rownames(cts_filtpoa))

rm(dds_filt)
```


### Size Factors
There is also an option to include size factors for each gene.

```{r}
sizeFactors_filt <- estimateSizeFactorsForMatrix(cts_filtpoa)
```

## Fitting Models

In this case study we want to use time and response as fixed effects and the patients as random effects:

> gene expression ~ Origin * Treatment + (1 | Colony)

To fit this model for all genes we can use the glmmSeq function.

```{r, eval=FALSE}
results_filt <- glmmSeq(~ Treatment * Origin + (1 | Colony),
                   countdata = cts_filtpoa,
                   metadata = coldata,
                   dispersion = dispersions_filt,
                   progress = TRUE)

saveRDS(results_filt, file = "filt_fit.rds")
```

Showed errors in one gene, Pocillopora_acuta_HIv2___RNAseq.g3772.t2.

```{r}
results_filt <- readRDS(file = "filt_fit.rds")
results_filt@errors   # first gene error
```

```{r}
cts_filtpoa %>% filter(row.names(cts_filtpoa) %in% c('Pocillopora_acuta_HIv2___RNAseq.g3772.t2')) %>% unlist
```


## Hypothesis testing

```{r, eval=FALSE}
glmmLRT <- glmmSeq(~ Treatment * Origin + (1 | Colony),
                   reduced = ~ Treatment + Origin + (1 | Colony),
                   countdata = cts_filtpoa,
                   metadata = coldata,
                   dispersion = dispersions_filt, verbose = FALSE)
saveRDS(glmmLRT, file = "glmmLRT.rds")
rm(glmmLRT)
```


```{r}
glmmLRT <- readRDS(file = "glmmLRT.rds")

summary(glmmLRT, "Pocillopora_acuta_HIv2___TS.g25814.t1")
```


### Outputs
```{r}
names(attributes(results_filt))
results_filt@modelData
```

Model fit statistics, w/ p-value ordered by Origin:Treatment:
```{r}
stats_filt <- summary(results_filt)

kable(stats_filt[order(stats_filt[, 'P_Treatment:Origin']), ]) %>%
  kable_styling() %>%
  scroll_box(width = "100%", height = "400px")
```


Summary stats for a specific gene.
```{r}
summary(results_filt, gene = "Pocillopora_acuta_HIv2___TS.g25814.t1")
```

Estimated means based on each geneâ€™s fitted model to show fixed effects and their 95% confidence intervals can be seen in the @predict slot:

```{r}
predict_filt = data.frame(results_filt@predict)
kable(predict_filt) %>%
  kable_styling() %>%
  scroll_box(width = "100%", height = "400px")
```


### Q values

```{r}
results_filt <- glmmQvals(results_filt) # adds a matrix to the results object containign Q-vals
```

## Model Plots

Does not work when x1var, which in our case is Treatment, is a factor.
```{r}
# ggmodelPlot(results_filt,
#             geneName = "Pocillopora_acuta_HIv2___TS.g25814.t1",
#             x1var = "Treatment",
#             x2var="Origin")
```


```{r}
fcPlot(results_filt, x1var = "Origin", x2var = "Treatment", graphics = "plotly",
       pCutoff = 0.05, useAdjusted = TRUE)
```


## MA Plots
```{r}
maPlots_filt <- maPlot(results_filt,
                  x1var="Treatment",
                  x2var="Origin",
                  x2Values=c("Flat", "Slope"),
                  graphics="ggplot")

maPlots_filt$combined
```


## Alternative: Using transformed data?

There is an alternative way to fit the model using glmmTMB that does not require calculating dispersions: "Setting method = "glmmTMB" when calling glmmSeq() switches from using lme4::glmer (the default) to the glmmTMB package". Choosing to use the default and calculate dispersion using Deseq/EdgeR here.

**I want to read more about the Gaussian mixed effects models + using "variance stabilising transformation (VST) can be applied to count data through DESeq2 or the voom transformation in limma voom."**

