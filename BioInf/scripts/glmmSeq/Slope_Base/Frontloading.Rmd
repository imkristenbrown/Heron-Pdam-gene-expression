---
title: "Frontloading Analysis after glmmSeq, Slope as Base Level"
author: "Zoe Dellaert"
date: "4/24/2023"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This is a Rmd file analyzing our raw count data by the glmmSeq package as described in the [vignette](https://cran.r-project.org/web/packages/glmmSeq/vignettes/glmmSeq.html) and [manual](https://cran.r-project.org/web/packages/glmmSeq/glmmSeq.pdf).

```{r}
sessionInfo() #provides list of loaded packages and version of R. I still have version 4.1 for now.
```

```{r cars}
library(dplyr)
library(reshape2)
sessionInfo() #list of packages after library-ing these packages
```

From glmmSeq, I saved the following output:

- "signif_genes_rawcts.csv" #save this as csv for downstream analysis
- "signif_genes_cts.csv" #save this as csv for downstream analysis
- "signif_genes_normcts.csv" #save this as csv for downstream analysis

I am going to start by using the normalized counts data frame, we can change this if needed. Most of the analysis uses the first 29 columns, which is the same for all 3 csvs.

```{r DEGs by variable list}
DEGs <- read.csv(file="../../../output/Slope_Base/signif_genes_normcts.csv", sep=',', header=TRUE)  %>% dplyr::select(!c('X'))

rownames(DEGs) <- DEGs$Gene
```

Lets also pull in our metadata

```{r}
coldata <- read.csv("../../../../RAnalysis/Data/RNA Submission Sample List metadata.csv") #read in metadata file
coldata <- plyr::rename(coldata, c("Sample.Name"="Coral_ID")) #Make a column that represents the colonies
coldata$Colony <- gsub("A", "", coldata$Coral_ID) #ID which sample is from which colony by remobing letters after colony name
coldata$Colony <- gsub("B", "", coldata$Colony) #ID which sample is from which colony by remobing letters after colony name
coldata$Colony <- gsub("C", "", coldata$Colony) #ID which sample is from which colony by remobing letters after colony name
coldata$Colony <- gsub("D", "", coldata$Colony) #ID which sample is from which colony by remobing letters after colony name

coldata$Origin <- factor(coldata$Origin) #set variables to factors
coldata$Colony <- factor(coldata$Colony) #set variables to factors
coldata$Treatment <- factor(coldata$Treatment) #set variables to factors

coldata <- coldata %>% filter(Coral_ID != c("RF16A","RF16C")) #removed outlier rows from metadata
head(coldata)
```

## Whole dataset: All 9011 genes

```{r}
melted <- DEGs %>% dplyr::select(c('Gene',coldata$Coral_ID)) %>%  #keep only the columns with the gene name and normalized count per sample
            reshape2::melt(id.var = 'Gene') %>% #melt by Gene so it is in long form with one observation of a gene-sample pair and its normalized count per row, 414506 rows for 9011 genes * 46 samples
            dplyr::rename(Coral_ID = variable) %>% dplyr::rename(norm_count = value)

melted_merge <- merge(melted, coldata, by = 'Coral_ID') %>% 
                        dplyr::group_by(Gene, Origin, Treatment) %>%  #should  I only group by origin here or by treatment and origin?
                        dplyr::select(!'Coral_ID') %>% 
                        dplyr::summarise(meanExp = mean(norm_count))

#this gives us a mean expression value per condition, which we already had through glmmSeq  (predData) 

melted_merge_READY <- dcast(melted_merge, Gene ~ Origin + Treatment)
```

Let's see if the means calculated here match with what glmmSeq predicted

```{r}
glmmSeq_predict <- read.csv(file="../../../output/Slope_Base/model_expression_prediction_allgenes.csv", sep=',', header=TRUE) %>% dplyr::rename("Gene" = 'X')

READY <- glmmSeq_predict %>%
    dplyr::select(!contains("LCI_")) %>% #drop the confidence interval columns for now 
    dplyr::select(!contains("UCI_")) %>% #drop the confidence interval columns for now 
    dplyr::arrange(Gene) # sort by gene name
```

They are close but not exactly the same #s. Let's stick with the glmmSeq values.

```{r}
# we have our final dataset ready to rock! 'READY' :-) 
# lets calculate the x and y axis of the frontloading figure following Barshis et al. 2013 criteria 

# X axis - this is the relative fold ratio of the conditioned-control to the naive-control as the following: 
# [ (MM/MA) / (AM/AA) ]

#for our purposes, conditioned = Flat and naive = Slope, Ambient = Stable, and Moderate = Variable


# X axis - this is the relative fold ratio of the conditioned-control to the naive-control as the following: 
# [ (Variable_Flat/Stable_Flat) / (Variable_Slope/Stable_Slope) ]
# like a ratio of a ratio.. the values <1 will indicate genes that are lower response to stress than the naive animals (opposite for values >1)

# lets calculate it 

colnames(READY)

xall_1 <- ( (READY$y_Variable_Flat / READY$y_Stable_Flat) / (READY$y_Variable_Slope / READY$y_Stable_Slope) ) # call y_Stable_Flat as the control for the y_Variable_Flat ratio

xall_2 <- ( (READY$y_Variable_Flat / READY$y_Stable_Slope) / (READY$y_Variable_Slope / READY$y_Stable_Slope) ) # call y_Stable_Slope as the control for the y_Variable_Flat ratio

xall_3 <- (READY$y_Variable_Flat / READY$y_Variable_Slope)  # call y_Stable_Slope as the control for the y_Variable_Flat ratio

# Xall 2 and Xall3 are the exact same ratios.

READY$xall_1 <- xall_1
READY$xall_2 <- xall_2
READY$xall_3 <- xall_3

# Y Axis - this is simply the conditioned control over the naive control 
# ( MA / AA ) 

# lets calculate it 
yall <- (READY$y_Stable_Flat / READY$y_Stable_Slope)

READY$yall <- yall
```


```{r}
# lets plot it! 
library(ggplot2)


READY$color <- rep('gray', nrow(READY))
#These are "frontloaded, need a different color:
READY$color[READY$yall > 1 & READY$xall_1 < 1] <- 'black'

P_allgenes <- READY %>% #dplyr::filter(yall < 6) %>% 
        ggplot(aes(x=xall_1, y=yall)) +
        geom_point(colour = READY$color) +
        theme_classic() + 
        stat_smooth(method = "lm", formula = y ~ x + poly(x, 2) - 1) +
        geom_vline(xintercept=1, linetype="dotted") + 
        geom_hline(yintercept=1, linetype="dotted") + 
        labs(y= "Flat to Slope (Conditioned to naive) control ratio", 
             x = "Flat to Slope (Conditioned to naive) foldchange ratio",
             title = "Frontloaded genes") +
        annotate("rect", xmin = 0, xmax = 1, ymin = 1, ymax = max(yall) + 1, alpha = .2) + 
        annotate("rect", xmin = 0, xmax = 1, ymin = 0, ymax = 1,alpha = .5)

P_allgenes

READY_cutoff <- READY %>% dplyr::filter(yall < 6) %>% dplyr::filter(xall_1 < 6)

P <- READY_cutoff %>% 
        ggplot(aes(x=xall_1, y=yall)) +
        geom_point(colour = READY_cutoff$color) +
        theme_classic() + 
        stat_smooth(method = "lm", formula = y ~ x + poly(x, 2) - 1) +
        geom_vline(xintercept=1, linetype="dotted") + 
        geom_hline(yintercept=1, linetype="dotted") + 
        labs(y= "Flat to Slope (Conditioned to naive) control ratio", 
             x = "Flat to Slope (Conditioned to naive) foldchange ratio",
             title = "Frontloaded genes") + 
        scale_x_continuous(limits = c(0,6.1),expand = c(0, 0)) + scale_y_continuous(limits = c(0,6.1), expand = c(0, 0)) + 
        annotate("rect", xmin = 0, xmax = 1, ymin = 1, ymax = 6.1, alpha = .2) + 
        annotate("rect", xmin = 0, xmax = 1, ymin = 0, ymax = 1,alpha = .5)

P
```

```{r}
#color DE genes by origin

DEGs_Origin <- DEGs %>%
  filter(Origin < 0.05) %>%
  pull(Gene)

DEGs_Treatment <- DEGs %>%
  filter(Treatment < 0.05) %>%
  pull(Gene)

READY$color <- rep('gray', nrow(READY))
#These are "frontloaded, need a different color:
#READY$color[READY$yall > 1 & READY$xall_1 < 1] <- 'black'
READY$color[READY$Gene %in% DEGs_Origin] <- 'purple'
READY$color[READY$Gene %in% DEGs_Treatment] <- 'red'

P_allgenes <- READY %>% #dplyr::filter(yall < 6) %>% 
        ggplot(aes(x=xall_1, y=yall)) +
        geom_point(colour = READY$color) +
        theme_classic() + 
        stat_smooth(method = "lm", formula = y ~ x + poly(x, 2) - 1) +
        geom_vline(xintercept=1, linetype="dotted") + 
        geom_hline(yintercept=1, linetype="dotted") + 
        labs(y= "Flat to Slope (Conditioned to naive) control ratio", 
             x = "Flat to Slope (Conditioned to naive) foldchange ratio",
             title = "Frontloaded genes") +
        annotate("rect", xmin = 0, xmax = 1, ymin = 1, ymax = max(yall) + 1, alpha = .2) + 
        annotate("rect", xmin = 0, xmax = 1, ymin = 0, ymax = 1,alpha = .5)

P_allgenes

READY_cutoff <- READY %>% dplyr::filter(yall < 6) %>% dplyr::filter(xall_1 < 6)

P <- READY_cutoff %>% 
        ggplot(aes(x=xall_1, y=yall)) +
        geom_point(colour = READY_cutoff$color, alpha=0.8) +
        theme_classic() + 
        stat_smooth(method = "lm", formula = y ~ x + poly(x, 2) - 1) +
        geom_vline(xintercept=1, linetype="dotted") + 
        geom_hline(yintercept=1, linetype="dotted") + 
        labs(y= "Flat to Slope (Conditioned to naive) control ratio", 
             x = "Flat to Slope (Conditioned to naive) foldchange ratio",
             title = "Frontloaded genes") + 
        scale_x_continuous(limits = c(0,6.1),expand = c(0, 0)) + scale_y_continuous(limits = c(0,6.1), expand = c(0, 0)) + 
        annotate("rect", xmin = 0, xmax = 1, ymin = 1, ymax = 6.1, alpha = .2) + 
        annotate("rect", xmin = 0, xmax = 1, ymin = 0, ymax = 1,alpha = .5)

P
```


-------

We need to interrogate the super high values: resulting from dividing by "zeros" (0.00001)

Subsetting out "frontloaded" genes

```{r}
P_frontloaded <- READY %>% dplyr::filter(yall > 1) %>% dplyr::filter(xall_1 < 1) 

dim(P_frontloaded)

head(P_frontloaded$Gene)
```

2631 genes are frontloaded, with a yall ratio larger than 1 and a xall_1 ratio less than 1.

```{r}
P_frontloaded_genes <- DEGs[which(DEGs$Gene %in% P_frontloaded$Gene),]

P_frontloaded_genes <- full_join(P_frontloaded_genes,P_frontloaded)
write.csv(P_frontloaded_genes, "../../../output/Slope_Base/frontloaded_genes.csv") #save this as csv for downstream analysis
```

These will then go into enrichment.


-------

```{r}
#what is the overlap between DEGs and frontloaded genes?

sum(P_frontloaded_genes$Origin < 0.05) #231 of the 840 DEGs by origin are in the frontloaded set

sum(P_frontloaded_genes$Treatment < 0.05) #3 of the 18 DEGs by treatment are in the frontloaded set

sum(P_frontloaded_genes$Treatment.Origin < 0.05) #4 of the 30 DEGs by treatment:origin interaction are in the frontloaded set
```


-------

```{r}
# Calculate the mean of each column

means <- P_frontloaded %>% summarise(
                          mean_Stable_Slope = mean(y_Stable_Slope),
                          mean_Variable_Slope = mean(y_Variable_Slope),
                          mean_Stable_Flat = mean(y_Stable_Flat),
                          mean_Variable_Flat = mean(y_Variable_Flat)
                          )
  
# Calculate the standard error of the selected columns

standard_errors <- P_frontloaded %>% summarise(
                          sd_Stable_Slope = sd(y_Stable_Slope) / sqrt(n()),
                          sd_Variable_Slope = sd(y_Variable_Slope) / sqrt(n()),
                          sd_Stable_Flat = sd(y_Stable_Flat) / sqrt(n()),
                          sd_Variable_Flat = sd(y_Variable_Flat) / sqrt(n())
                          )

library(reshape2)

# Melt the means and standard errors into a longer format
melted_means <- melt(means)
melted_standard_errors <- melt(standard_errors)


# Combine the melted data
combined_data <- cbind(melted_means, melted_standard_errors$value) %>% rename("se" = "melted_standard_errors$value")

combined_data$Origin <- c("Slope", "Slope", "Flat", "Flat")
combined_data$Treatment <- c("Stable", "Variable", "Stable", "Variable")

# Plot the means as points with error bars
ggplot(combined_data, aes(x = Treatment, y = value, color = Origin)) +
  geom_errorbar(aes(ymin = value -  se, ymax = value + se, color = Origin), width = 0.05) +
  geom_line(aes(group = Origin), color = "darkgrey") +
   geom_point(size = 3) + 
  labs(x = "Treatment", y = "glmmSeq Predicted Gene Expression (mean +- SE)") +
  theme_minimal()

#want to redo this with the vst gene expression at some point
```

```{r}
P_frontloaded_bygroup <- P_frontloaded %>% dplyr::select("y_Stable_Slope", "y_Variable_Slope", "y_Stable_Flat", "y_Variable_Flat") %>% pivot_longer(cols = c("y_Stable_Slope", "y_Variable_Slope", "y_Stable_Flat", "y_Variable_Flat"), names_to = "group", values_to = "expression") %>% mutate(group2 = group) %>% separate("group", c("y","Treatment","Origin")) %>% dplyr::select(-c("y"))

P_frontloaded_bygroup

ggplot(P_frontloaded_bygroup, aes(x = Treatment, y = expression, fill= interaction(Origin, Treatment))) +
  geom_boxplot(position = position_dodge(width = 0.8)) +  # Use position_dodge for grouping
  stat_summary(
    fun = mean,       # Calculate mean
    geom = "point",   # Display as points
    position = position_dodge(width = 0.8),  # Use position_dodge for grouping
    size = 3,         # Point size
    shape = 18,       # Point shape (filled circle)
    color = "black"   # Point color
  ) +
  labs(x = "Treatment", y = "glmmSeq Predicted Gene Expression (mean +- SE)") +
  theme_minimal()  +  coord_cartesian(ylim = c(0,200))
```

```{r}
# Normality test
shapiro.test(P_frontloaded_bygroup$expression[P_frontloaded_bygroup$group2 == "y_Stable_Slope"])
shapiro.test(P_frontloaded_bygroup$expression[P_frontloaded_bygroup$group2 == "y_Variable_Slope"])
shapiro.test(P_frontloaded_bygroup$expression[P_frontloaded_bygroup$group2 == "y_Stable_Flat"])
shapiro.test(P_frontloaded_bygroup$expression[P_frontloaded_bygroup$group2 == "y_Variable_Flat"])

# Data is not normally distributed
```


```{r}
# Perform Kruskal-Wallis test
kruskal_test <- kruskal.test(expression ~ group2, data = P_frontloaded_bygroup)

# Check the Kruskal-Wallis test results
print(kruskal_test)


library(dunn.test)

# Conduct Dunn's post-hoc test
posthoc_dunn <- dunn.test(P_frontloaded_bygroup$expression, g = P_frontloaded_bygroup$group2, method = "bonferroni")

# Check the post-hoc test results
print(posthoc_dunn)
```



```{r}
#load in vst normalized gene expression

vst <- read.csv(file="../../../output/Slope_Base/vst.csv", sep=',', header=TRUE)  %>% dplyr::select(!c('X'))
```


```{r}
#  reaction norm data config and plotting 
vst_front  <- vst[which(vst$Gene %in% P_frontloaded$Gene),]

vst_front  <- vst_front %>%  reshape2::melt(id.var = 'Gene') %>% 
                    dplyr::rename(Coral_ID = variable)

vst_front_Merge <- merge(vst_front, coldata, by = 'Coral_ID') %>% 
    mutate(group = paste(Treatment, Origin, sep = "_"))
  

vst_summary <- vst_front_Merge %>%
  #select(value, Gene, group) %>%
  group_by(Gene, Treatment, Origin) %>%
  summarise(mean_val = mean(value),
            sd_val = sd(value),
            se_val = sd_val/sqrt(n())) %>%
  ungroup()

group_summary <- vst_summary %>%
  group_by(Treatment, Origin) %>%
  summarise(meanExp = mean(mean_val),
            sdExp = sd(mean_val),
            n = n(),
            se = sdExp/sqrt(n))

# anova
ANOVA_moderate <- aov(lm(value~as.character(group), data = vst_front_Merge))
summary(ANOVA_moderate) # as.character(group)      3    355   118.3   196.2 <2e-16 ***
TukeyHSD(ANOVA_moderate)

#                                     diff         lwr         upr    p adj
# Stable_Slope-Stable_Flat     -0.14750296 -0.16373730 -0.13126863 0.00e+00
# Variable_Flat-Stable_Flat    -0.04063634 -0.05721984 -0.02405284 0.00e+00
# Variable_Slope-Stable_Flat   -0.07025845 -0.08649279 -0.05402411 0.00e+00
# Variable_Flat-Stable_Slope    0.10686662  0.09063228  0.12310095 0.00e+00
# Variable_Slope-Stable_Slope   0.07724451  0.06136702  0.09312200 0.00e+00
# Variable_Slope-Variable_Flat -0.02962211 -0.04585644 -0.01338777 1.64e-05


#Chi squre test
library(lsmeans)

example.glm = glm(value ~ group, data = vst_front_Merge)

lsmeans(example.glm, pairwise ~ group)

# contrast                       estimate      SE     df t.ratio p.value
#  Stable_Flat - Stable_Slope       0.1475 0.00632 121022  23.342  <.0001
#  Stable_Flat - Variable_Flat      0.0406 0.00646 121022   6.295  <.0001
#  Stable_Flat - Variable_Slope     0.0703 0.00632 121022  11.118  <.0001
#  Stable_Slope - Variable_Flat    -0.1069 0.00632 121022 -16.911  <.0001
#  Stable_Slope - Variable_Slope   -0.0772 0.00618 121022 -12.498  <.0001
#  Variable_Flat - Variable_Slope   0.0296 0.00632 121022   4.688  <.0001


ggplot(group_summary, aes(x = Treatment, y = meanExp, color = Origin)) +
  geom_errorbar(aes(ymin = meanExp -  se, ymax = meanExp + se, color = Origin), width = 0.05) +
  geom_line(aes(group = Origin), color = "darkgrey") +
   geom_point(size = 3) + 
  labs(x = "Treatment", y = "VST Mean Gene Expression (mean +- SE)") +
  theme_minimal()


ggplot(group_summary, aes(x = Treatment, y = meanExp, fill = Origin, group = Origin)) +
  geom_line(aes(linetype = Origin), size = 0.5) +
  geom_pointrange(aes(ymin=meanExp-se, ymax=meanExp+se, shape=Origin, fill=Origin)) + 
                      scale_shape_manual(values=c(1, 16))+
                      scale_fill_manual(values=c('black','white')) +
                      theme_classic() +
  scale_linetype_manual(values = c("Slope" = "solid", "Flat" = "dashed"))  +
                      labs(y= "mean SE VST expression", 
                           x = "Treatment",
                           title = "Mean VST Expression of Frontloaded Genes") + 
   theme(text = element_text(size=15)) +
                      scale_y_continuous(limits = c(7.28,7.48), breaks = seq(7.2,7.5, by = .1)) +
                        annotate(geom="text", x=0.94, y=7.31, label="c", color="black",size=4) +
                        annotate(geom="text", x=0.94, y=7.46,  label="a", color="black",size=4) +
                        annotate(geom="text", x=2.06, y=7.39, label="d", color="black",size=4) +
                        annotate(geom="text", x=2.06, y=7.42,  label="b", color="black",size=4) +
                        annotate(geom="text", x = 2.1, y = 7.3, label=paste("N = ",group_summary$n[1]), size = 5) + guides(fill = FALSE, shape = FALSE)


```


