---
title: "Frontloading Analysis after glmmSeq, Slope as Base Level"
author: "Zoe Dellaert"
date: "4/24/2023"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This is a Rmd file analyzing our raw count data by the glmmSeq package as described in the [vignette](https://cran.r-project.org/web/packages/glmmSeq/vignettes/glmmSeq.html) and [manual](https://cran.r-project.org/web/packages/glmmSeq/glmmSeq.pdf).

```{r}
sessionInfo() #provides list of loaded packages and version of R. I still have version 4.1 for now.
```

```{r cars}
library(dplyr)
library(reshape2)
sessionInfo() #list of packages after library-ing these packages
```

From glmmSeq, I saved the following output:

- "signif_genes_rawcts.csv" #save this as csv for downstream analysis
- "signif_genes_cts.csv" #save this as csv for downstream analysis
- "signif_genes_normcts.csv" #save this as csv for downstream analysis

I am going to start by using the normalized counts data frame, we can change this if needed. Most of the analysis uses the first 29 columns, which is the same for all 3 csvs.

```{r DEGs by variable list}
DEGs <- read.csv(file="../../../output/Slope_Base/signif_genes_normcts.csv", sep=',', header=TRUE)  %>% dplyr::select(!c('X'))

rownames(DEGs) <- DEGs$Gene
```

Lets also pull in our metadata

```{r}
coldata <- read.csv("../../../../RAnalysis/Data/RNA Submission Sample List metadata.csv") #read in metadata file
coldata <- plyr::rename(coldata, c("Sample.Name"="Coral_ID")) #Make a column that represents the colonies
coldata$Colony <- gsub("A", "", coldata$Coral_ID) #ID which sample is from which colony by remobing letters after colony name
coldata$Colony <- gsub("B", "", coldata$Colony) #ID which sample is from which colony by remobing letters after colony name
coldata$Colony <- gsub("C", "", coldata$Colony) #ID which sample is from which colony by remobing letters after colony name
coldata$Colony <- gsub("D", "", coldata$Colony) #ID which sample is from which colony by remobing letters after colony name

coldata$Origin <- factor(coldata$Origin) #set variables to factors
coldata$Colony <- factor(coldata$Colony) #set variables to factors
coldata$Treatment <- factor(coldata$Treatment) #set variables to factors

coldata <- coldata %>% filter(Coral_ID != c("RF16A","RF16C")) #removed outlier rows from metadata
head(coldata)
```

## Whole dataset: All 9011 genes

```{r}
melted <- DEGs %>% dplyr::select(c('Gene',coldata$Coral_ID)) %>%  #keep only the columns with the gene name and normalized count per sample
            reshape2::melt(id.var = 'Gene') %>% #melt by Gene so it is in long form with one observation of a gene-sample pair and its normalized count per row, 414506 rows for 9011 genes * 46 samples
            dplyr::rename(Coral_ID = variable) %>% dplyr::rename(norm_count = value)

melted_merge <- merge(melted, coldata, by = 'Coral_ID') %>% 
                        dplyr::group_by(Gene, Origin, Treatment) %>%  #should  I only group by origin here or by treatment and origin?
                        dplyr::select(!'Coral_ID') %>% 
                        dplyr::summarise(meanExp = mean(norm_count))

#this gives us a mean expression value per condition, which we already had through glmmSeq  (predData) 

#should  I only group by origin here or by treatment and origin?

# melted_merge_org <- melted_merge %>% 
#                         dplyr::group_by(Gene, Origin) %>% 
#                         dplyr::summarise(meanExp = mean(meanExp))

melted_merge_READY <- dcast(melted_merge, Gene ~ Origin + Treatment)
```

Let's see if the means calculated here match with what glmmSeq predicted

```{r}
glmmSeq_predict <- read.csv(file="../../../output/Slope_Base/model_expression_prediction_allgenes.csv", sep=',', header=TRUE) %>% dplyr::rename("Gene" = 'X')

READY <- glmmSeq_predict %>%
    dplyr::select(!contains("LCI_")) %>% #drop the confidence interval columns for now 
    dplyr::select(!contains("UCI_")) %>% #drop the confidence interval columns for now 
    dplyr::arrange(Gene) # sort by gene name
```

They are close but not exactly the same #s. Let's stick with the glmmSeq values.

```{r}
# we have our final dataset ready to rock! 'READY' :-) 
# lets calculate the x and y axis of the frontloading figure following Barshis et al. 2013 criteria 

# X axis - this is the relative fold ratio of the conditioned-control to the naive-control as the following: 
# [ (MM/MA) / (AM/AA) ]

#for our purposes, conditioned = Flat and naive = Slope, Ambient = Stable, and Moderate = Variable


# X axis - this is the relative fold ratio of the conditioned-control to the naive-control as the following: 
# [ (Variable_Flat/Stable_Flat) / (Variable_Slope/Stable_Slope) ]
# like a ratio of a ratio.. the values <1 will indicate genes that are lower response to stress than the naive animals (opposite for values >1)

# lets calculate it 

colnames(READY)

xall_1 <- ( (READY$y_Variable_Flat / READY$y_Stable_Flat) / (READY$y_Variable_Slope / READY$y_Stable_Slope) ) # call y_Stable_Flat as the control for the y_Variable_Flat ratio

xall_2 <- ( (READY$y_Variable_Flat / READY$y_Stable_Slope) / (READY$y_Variable_Slope / READY$y_Stable_Slope) ) # call y_Stable_Slope as the control for the y_Variable_Flat ratio

xall_3 <- (READY$y_Variable_Flat / READY$y_Variable_Slope)  # call y_Stable_Slope as the control for the y_Variable_Flat ratio

# Xall 2 and Xall3 are the exact same ratios.

READY$xall_1 <- xall_1
READY$xall_2 <- xall_2
READY$xall_3 <- xall_3

# Y Axis - this is simply the conditioned control over the naive control 
# ( MA / AA ) 

# lets calculate it 
yall <- (READY$y_Stable_Flat / READY$y_Stable_Slope)

READY$yall <- yall

```


```{r}
# lets plot it! 
library(ggplot2)

P_allgenes <- READY %>% #dplyr::filter(yall < 6) %>% 
        ggplot(aes(x=xall_1, y=yall)) +
        geom_point() +
        theme_classic() + 
        stat_smooth(method = "lm", formula = y ~ x + poly(x, 2) - 1) +
        geom_vline(xintercept=1, linetype="dotted") + 
        geom_hline(yintercept=1, linetype="dotted") + 
        labs(y= "Flat to Slope (Conditioned to naive) control ratio", 
             x = "Flat to Slope (Conditioned to naive) foldchange ratio",
             title = "Frontloaded genes") +
        annotate("rect", xmin = 0, xmax = 1, ymin = 1, ymax = max(yall) + 1, alpha = .2) + 
        annotate("rect", xmin = 0, xmax = 1, ymin = 0, ymax = 1,alpha = .5)

P_allgenes

P <- READY %>% dplyr::filter(yall > 1) %>% dplyr::filter(xall_1 < 6) %>% 
        ggplot(aes(x=xall_1, y=yall)) +
        geom_point() +
        theme_classic() + 
        stat_smooth(method = "lm", formula = y ~ x + poly(x, 2) - 1) +
        geom_vline(xintercept=1, linetype="dotted") + 
        geom_hline(yintercept=1, linetype="dotted") + 
        labs(y= "Flat to Slope (Conditioned to naive) control ratio", 
             x = "Flat to Slope (Conditioned to naive) foldchange ratio",
             title = "Frontloaded genes") + 
        scale_x_continuous(limits = c(0,6.1),expand = c(0, 0)) + scale_y_continuous(limits = c(0,6.1), expand = c(0, 0)) + 
        annotate("rect", xmin = 0, xmax = 1, ymin = 1, ymax = 6.1, alpha = .2) + 
        annotate("rect", xmin = 0, xmax = 1, ymin = 0, ymax = 1,alpha = .5)

P
```


-------

We need to interrogate the super high values: resulting from dividing by "zeros" (0.00001)

Subsetting out "frontloaded" genes

```{r}
#P_frontloaded <- READY %>% dplyr::filter(yall > 1) %>% dplyr::filter(xall_1 < 1) %>% select(Gene) %>% unlist

#length(P_frontloaded)

P_frontloaded <- READY %>% dplyr::filter(yall > 1) %>% dplyr::filter(xall_1 < 1) 

dim(P_frontloaded)

P_frontloaded$Gene
```

2631 genes are frontloaded, with a yall ratio larger than 1 and a xall_1 ratio less than 1.

```{r}
P_frontloaded_genes <- DEGs[which(DEGs$Gene %in% P_frontloaded$Gene),]

P_frontloaded_genes <- full_join(P_frontloaded_genes,P_frontloaded)
write.csv(P_frontloaded_genes, "../../../output/Slope_Base/frontloaded_genes.csv") #save this as csv for downstream analysis
```

These will then go into enrichment.


