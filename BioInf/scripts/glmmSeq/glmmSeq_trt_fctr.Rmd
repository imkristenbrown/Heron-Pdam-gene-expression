---
title: "glmmSeq_trt_fctr"
author: "Zoe Dellaert"
date: "3/8/2023"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This is a Rmd file analyzing our raw count data by the glmmSeq package as described in the [vignette](https://cran.r-project.org/web/packages/glmmSeq/vignettes/glmmSeq.html) and [manual](https://cran.r-project.org/web/packages/glmmSeq/glmmSeq.pdf).

```{r}
sessionInfo() #provides list of loaded packages and version of R. I still have version 4.1 for now.
```

First, download the glmmSeq package. I had to install qvalue using BiocManager as described in the [vignette](https://cran.r-project.org/web/packages/glmmSeq/vignettes/glmmSeq.html)

```{r install packages, eval=FALSE}
#if (!requireNamespace("BiocManager", quietly = TRUE))
    #install.packages("BiocManager")
    #BiocManager::install("qvalue"))

#install.packages("glmmSeq") #from CRAN
#devtools::install_github("myles-lewis/glmmSeq") # from github
#install.packages("plotly")
```

Next, load the package 
  
```{r}
library(glmmSeq)
library(dplyr) #load dplyr, which is required to run this tutorial but not included in the vignette
library(kableExtra) #load kableExtra, which is also required to run this tutorial but not included in the vignette
library(plotly)
sessionInfo()
```


and load in raw count data
```{r}
cts_raw <- read.csv("../../TagSeq_Output/HeronPdam_gene_count_matrix.csv") #load in data
rownames(cts_raw) <- cts_raw[,1]
cts_raw <- cts_raw[,-1]
head(cts_raw[,1:10])
```


```{r}
colnames(cts_raw)<-gsub("_[^_]+$", "",colnames(cts_raw))
colnames(cts_raw)<-gsub("_[^_]+$", "",colnames(cts_raw))
colnames(cts_raw)
```

Metadata from this dataset
```{r}
coldata <- read.csv("../../../RAnalysis/Data/RNA Submission Sample List metadata.csv")
coldata <- plyr::rename(coldata, c("Sample.Name"="Coral_ID"))
coldata$Colony <- gsub("A", "", coldata$Coral_ID)
coldata$Colony <- gsub("B", "", coldata$Colony)
coldata$Colony <- gsub("C", "", coldata$Colony)
coldata$Colony <- gsub("D", "", coldata$Colony)
coldata <- as.data.frame(coldata)
coldata$Origin <- factor(coldata$Origin)
coldata$Colony <- factor(coldata$Colony)
coldata$Treatment <- factor(coldata$Treatment)
head(coldata)
```

Data sanity checks:
```{r}
all(rownames(coldata$Coral_ID) %in% colnames(cts_raw))
all(rownames(coldata$Coral_ID) == colnames(cts_raw))
```

## Using filtered data instead of raw counts as input

```{r}
cts_filt<-cts_raw[rowSums(!as.matrix(cts_raw)) < ncol(cts_raw), ]#here we remove all genes that were not expressed in any of our samples- we are left with 24,333 genes.
```

```{r}
library(genefilter)
ffun<-filterfun(pOverA(0.25,10)) 
cts_filtpoa<- genefilter((cts_filt), ffun)
sum(cts_filtpoa)

cts_filtpoa <- cts_filt[cts_filtpoa,]
```

Data sanity checks:
```{r}
all(rownames(coldata$Coral_ID) %in% colnames(cts_filtpoa))
all(rownames(coldata$Coral_ID) == colnames(cts_filtpoa))
```


### Time to calculate dispersion!

"Using negative binomial models requires gene dispersion estimates to be made. This can be achieved in a number of ways. A common way to calculate this for gene i is to use the equation:

Dispersioni = (variancei - meani)/meani2

Starting with raw counts, so using [DESeq2](http://bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html), but could also import a normalized gene count matrix (i.e. transcripts per million) and calculate disperson manually as in the [vignette](https://cran.r-project.org/web/packages/glmmSeq/vignettes/glmmSeq.html).

```{r, eval = FALSE}
library(DESeq2)

dds_filt <- DESeqDataSetFromMatrix(countData = cts_filtpoa,
                              colData = coldata,
                              design = ~1) #this is what the glmmseq vignette says, cannot tell if we should put our formula in here yet or just calculate around the intercept.

# dds <- DESeqDataSetFromMatrix(countData = cts_raw,
#                               colData = coldata,
#                               design = ~ Treatment * Origin + (1 | Colony)) #ALTERNATIVE, but probably without the "1 | Colony" bit.

dds_filt <- DESeq(dds_filt)
dispersions_filt <- setNames(dispersions(dds_filt), rownames(cts_filtpoa))

rm(dds_filt)
```


### Size Factors
There is also an option to include size factors for each gene.

```{r, eval = FALSE}
sizeFactors_filt <- estimateSizeFactorsForMatrix(cts_filtpoa)
```

## Fitting Models

In this case study we want to use time and response as fixed effects and the patients as random effects:

> gene expression ~ Origin * Treatment + (1 | Colony)

To fit this model for all genes we can use the glmmSeq function.

```{r, eval=FALSE}
results_filt <- glmmSeq(~ Treatment * Origin + (1 | Colony),
                   countdata = cts_filtpoa,
                   metadata = coldata,
                   dispersion = dispersions_filt,
                   progress = TRUE)

saveRDS(results_filt, file = "filt_fit.rds")
```

Showed errors in one gene, Pocillopora_acuta_HIv2___RNAseq.g3772.t2.

```{r}
results_filt <- readRDS(file = "filt_fit.rds")
results_filt@errors   # first gene error
```

```{r}
cts_filtpoa %>% filter(row.names(cts_filtpoa) %in% c('Pocillopora_acuta_HIv2___RNAseq.g3772.t2')) %>% unlist
```


## Hypothesis testing

```{r, eval=FALSE}
glmmLRT <- glmmSeq(~ Treatment * Origin + (1 | Colony),
                   reduced = ~ Origin + (1 | Colony),
                   countdata = cts_filtpoa,
                   metadata = coldata,
                   dispersion = dispersions_filt, verbose = FALSE)
saveRDS(glmmLRT, file = "glmmLRT_Origin.rds")
rm(glmmLRT)
```


```{r, eval=FALSE}
glmmLRT <- readRDS(file = "glmmLRT_Origin.rds")

summary(glmmLRT, "Pocillopora_acuta_HIv2___TS.g25814.t1")

summary(results_filt, "Pocillopora_acuta_HIv2___TS.g25814.t1")
```


### Outputs
```{r}
names(attributes(results_filt))
results_filt@modelData
```

Model fit statistics, w/ p-value ordered by Origin:Treatment:
```{r}
stats_filt <- summary(results_filt)

kable(stats_filt[order(stats_filt[, 'P_Treatment:Origin']), ]) %>%
  kable_styling() %>%
  scroll_box(width = "100%", height = "400px")

write.csv(stats_filt[order(stats_filt[, 'P_Treatment:Origin']), ],"signif_genes_filt_outrm.csv")
```


Summary stats for a specific gene.
```{r}
summary(results_filt, gene = "Pocillopora_acuta_HIv2___TS.g25814.t1")
```

Estimated means based on each gene’s fitted model to show fixed effects and their 95% confidence intervals can be seen in the @predict slot:

```{r}
predict_filt = data.frame(results_filt@predict)
kable(predict_filt) %>%
  kable_styling() %>%
  scroll_box(width = "100%", height = "400px")
```


### Q values

```{r}
results_filt <- glmmQvals(results_filt) # adds a matrix to the results object containign Q-vals
```

## Model Plots

As written the plotting function from this package does not work when x1var, which in our case is Treatment, is a factor.

I changed the function to allow for discrete values on the X axis:

```{r}
source(file = "Factor_ggmodelPlot.R")

#I changed their code a lot and need to document all the changes

#formPlot(results_filt,geneName = "Pocillopora_acuta_HIv2___TS.g25814.t1",x1var = "Treatment",x2var="Origin",x2shift=NULL)

plotColours <- c("skyblue","mediumseagreen")
modColours <- c("dodgerblue3","seagreen4")
```


### most significant gene by Treatment:Origin:
```{r}
Factor_ggmodelPlot(results_filt,
            geneName = "Pocillopora_acuta_HIv2___TS.g25814.t1",
            x1var = "Treatment",
            x2var="Origin", addBox = T,
            xlab = "Treatment and Origin",
            colours = plotColours,
            lineColours = plotColours, 
            modelColours = modColours,
            modelSize = 3)

ggplotly(Factor_ggmodelPlot(results_filt,
            geneName = "Pocillopora_acuta_HIv2___TS.g25814.t1",
            x1var = "Treatment",
            x2var="Origin", addBox = T,
            xlab = "Treatment and Origin",
            colours = plotColours,
            lineColours = plotColours, 
            modelColours = modColours,
            modelSize = 3), tooltip="id")
```

### most significant gene by Treatment:
```{r}
ggplotly(Factor_ggmodelPlot(results_filt,
            geneName = "Pocillopora_acuta_HIv2___RNAseq.g13538.t2",
            x1var = "Treatment",
            x2var="Origin", addBox = T,
            xlab = "Treatment and Origin",
            colours = plotColours,
            lineColours = plotColours, 
            modelColours = modColours,
            modelSize = 3), tooltip="id")
```

### most significant gene by Origin:
```{r}
ggplotly(Factor_ggmodelPlot(results_filt,
            geneName = "Pocillopora_acuta_HIv2___TS.g25814.t1",
            x1var = "Treatment",
            x2var="Origin", addBox = T,
            xlab = "Treatment and Origin",
            colours = plotColours,
            lineColours = plotColours, 
            modelColours = modColours,
            modelSize = 3), tooltip="id")
```

```{r}
fcPlot(results_filt, x1var = "Origin", x2var = "Treatment", graphics = "plotly",
       pCutoff = 0.05, useAdjusted = TRUE)
```

```{r}
fcPlot(results_filt, x1var = "Treatment", x2var = "Origin", graphics = "plotly",
       pCutoff = 0.05, useAdjusted = TRUE)
```

## MA Plots

Fixed the script for the maplots , just added "scale_y_continuous(limits = c(-4.2,4.2), breaks = seq(-4,4, 2))" to make the scale the same on both plots.
```{r}
source("fixed_ylim_maPlot.R")
maPlots_filt <- fixed_ylim_maPlot(results_filt,
                  x1var="Treatment",
                  x2var="Origin",
                  x2Values=c("Flat", "Slope"),
                  graphics="ggplot")

maPlots_filt$combined
```

## Remmoving outlier "RF16A" and "RF16C"

```{r}
cts_raw_outrm <- cts_raw %>% select(-c("RF16A","RF16C"))
coldata_outrm <- coldata %>% filter(Coral_ID != c("RF16A","RF16C"))
cts_filt_outrm<-cts_raw_outrm[rowSums(!as.matrix(cts_raw_outrm)) < ncol(cts_raw_outrm), ]#here we remove all genes that were not expressed in any of our samples- we are left with 24,333 genes.
```

```{r}
library(genefilter)
ffun<-filterfun(pOverA(0.25,10)) 
cts_filt_outrm_poa<- genefilter((cts_filt_outrm), ffun)
sum(cts_filt_outrm_poa)

cts_filt_outrm_poa <- cts_filt_outrm[cts_filt_outrm_poa,]
```

After removing outliers, there are now 9012 genes in the filtered dataset.

Data sanity checks:
```{r}
all(rownames(coldata_outrm$Coral_ID) %in% colnames(cts_filt_outrm_poa))
all(rownames(coldata_outrm$Coral_ID) == colnames(cts_filt_outrm_poa))
```


### Time to calculate dispersion!

"Using negative binomial models requires gene dispersion estimates to be made. This can be achieved in a number of ways. A common way to calculate this for gene i is to use the equation:

Dispersioni = (variancei - meani)/meani2

Starting with raw counts, so using [DESeq2](http://bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html), but could also import a normalized gene count matrix (i.e. transcripts per million) and calculate disperson manually as in the [vignette](https://cran.r-project.org/web/packages/glmmSeq/vignettes/glmmSeq.html).

```{r, eval=FALSE}
library(DESeq2)

dds_filt_outrm <- DESeqDataSetFromMatrix(countData = cts_filt_outrm_poa,
                              colData = coldata_outrm,
                              design = ~1) #this is what the glmmseq vignette says, cannot tell if we should put our formula in here yet or just calculate around the intercept.

# dds <- DESeqDataSetFromMatrix(countData = cts_raw,
#                               colData = coldata,
#                               design = ~ Treatment * Origin + (1 | Colony)) #ALTERNATIVE, but probably without the "1 | Colony" bit.

dds_filt_outrm <- DESeq(dds_filt_outrm)
dispersions_filt_outrm <- setNames(dispersions(dds_filt_outrm), rownames(cts_filt_outrm_poa))

rm(dds_filt_outrm)
```


### Size Factors
There is also an option to include size factors for each gene.

```{r, eval=FALSE}
sizeFactors_filt <- estimateSizeFactorsForMatrix(cts_filt_outrm_poa)
```

## Fitting Models

In this case study we want to use time and response as fixed effects and the patients as random effects:

> gene expression ~ Origin * Treatment + (1 | Colony)

To fit this model for all genes we can use the glmmSeq function.

```{r, eval=FALSE}
results_filt_outrm <- glmmSeq(~ Treatment * Origin + (1 | Colony),
                   countdata = cts_filt_outrm_poa,
                   metadata = coldata_outrm,
                   dispersion = dispersions_filt_outrm,
                   progress = TRUE)

saveRDS(results_filt_outrm, file = "filt_fit_outrm.rds")
```

Showed errors in one gene, Pocillopora_acuta_HIv2___RNAseq.g5950.t1.

```{r}
results_filt_outrm <- readRDS(file = "filt_fit_outrm.rds")
results_filt_outrm@errors   # first gene error
```

```{r}
cts_filt_outrm_poa %>% filter(row.names(cts_filt_outrm_poa) %in% c('Pocillopora_acuta_HIv2___RNAseq.g5950.t1')) %>% unlist
```


## Hypothesis testing

```{r, eval=FALSE}
glmmLRT_outrm <- glmmSeq(~ Treatment * Origin + (1 | Colony),
                   reduced = ~ Treatment + Origin + (1 | Colony),
                   countdata = cts_filt_outrm_poa,
                   metadata = coldata,
                   dispersion = dispersions_filt_outrm, verbose = FALSE)
saveRDS(glmmLRT_outrm, file = "glmmLRT_outrm.rds")
rm(glmmLRT_outrm)
```


```{r, eval=FALSE}
glmmLRT_outrm <- readRDS(file = "glmmLRT_outrm.rds")

summary(glmmLRT_outrm, "Pocillopora_acuta_HIv2___TS.g25814.t1")

summary(results_filt_outrm, "Pocillopora_acuta_HIv2___TS.g25814.t1")
```


### Outputs
```{r}
names(attributes(results_filt_outrm))
results_filt_outrm@modelData
```

Model fit statistics, w/ p-value ordered by Origin:Treatment:
```{r}
stats_filt_outrm <- summary(results_filt_outrm)

kable(stats_filt_outrm[order(stats_filt_outrm[, 'P_Treatment:Origin']), ]) %>%
  kable_styling() %>%
  scroll_box(width = "100%", height = "400px")
```


Summary stats for a specific gene.
```{r}
summary(results_filt_outrm, gene = "Pocillopora_acuta_HIv2___TS.g25814.t1")
```

Estimated means based on each gene’s fitted model to show fixed effects and their 95% confidence intervals can be seen in the @predict slot:

```{r}
predict_filt_outrm = data.frame(results_filt_outrm@predict)
kable(predict_filt_outrm) %>%
  kable_styling() %>%
  scroll_box(width = "100%", height = "400px")
```


### Q values

```{r}
results_filt_outrm <- glmmQvals(results_filt_outrm) # adds a matrix to the results object containign Q-vals
```

## Model Plots

As written the plotting function from this package does not work when x1var, which in our case is Treatment, is a factor.

I changed the function to allow for discrete values on the X axis:

```{r}
source(file = "Factor_ggmodelPlot.R")

#I changed their code a lot and need to document all the changes

#formPlot(results_filt,geneName = "Pocillopora_acuta_HIv2___RNAseq.g13538.t2",x1var = "Treatment",x2var="Origin",x2shift=NULL)

plotColours <- c("skyblue","mediumseagreen")
modColours <- c("dodgerblue3","seagreen4")
```

### most significant gene by Treatment:Origin:
```{r}
ggplotly(Factor_ggmodelPlot(results_filt_outrm,
            geneName = "Pocillopora_acuta_HIv2___RNAseq.g14176.t1",
            x1var = "Treatment",
            x2var="Origin", addBox = T,
            xlab = "Treatment and Origin",
            colours = plotColours,
            lineColours = plotColours, 
            modelColours = modColours,
            modelSize = 3), tooltip="id")
```

### most significant gene by Treatment:
```{r}
ggplotly(Factor_ggmodelPlot(results_filt_outrm,
            geneName = "Pocillopora_acuta_HIv2___RNAseq.g13538.t2",
            x1var = "Treatment",
            x2var="Origin", addBox = T,
            xlab = "Treatment and Origin",
            colours = plotColours,
            lineColours = plotColours, 
            modelColours = modColours,
            modelSize = 3), tooltip="id")
```

### most significant gene by Origin:
```{r}
ggplotly(Factor_ggmodelPlot(results_filt_outrm,
            geneName = "Pocillopora_acuta_HIv2___RNAseq.g16163.t1",
            x1var = "Treatment",
            x2var="Origin", addBox = T,
            xlab = "Treatment and Origin",
            colours = plotColours,
            lineColours = plotColours, 
            modelColours = modColours,
            modelSize = 3), tooltip="id")
```


```{r}
fcPlot(results_filt_outrm, x1var = "Origin", x2var = "Treatment", graphics = "plotly",
       pCutoff = 0.05, useAdjusted = TRUE)
```

```{r}
fcPlot(results_filt_outrm, x1var = "Origin", x2var = "Colony", graphics = "plotly",
       pCutoff = 0.05, useAdjusted = TRUE)
```

```{r}
fcPlot(results_filt_outrm, x1var = "Treatment", x2var = "Origin", graphics = "plotly",
       pCutoff = 0.05, useAdjusted = TRUE)
```


## MA Plots

Fixed the script for the maplots , just added "scale_y_continuous(limits = c(-4.2,4.2), breaks = seq(-4,4, 2))" to make the scale the same on both plots.
```{r}
source("fixed_ylim_maPlot.R")
maPlots_filt_outrm <- fixed_ylim_maPlot(results_filt_outrm,
                  x1var="Treatment",
                  x2var="Origin",
                  x2Values=c("Flat", "Slope"),
                  graphics="ggplot")

maPlots_filt_outrm$combined
```


## Alternative: Using transformed data?

There is an alternative way to fit the model using glmmTMB that does not require calculating dispersions: "Setting method = "glmmTMB" when calling glmmSeq() switches from using lme4::glmer (the default) to the glmmTMB package". Choosing to use the default and calculate dispersion using Deseq/EdgeR here.

**I want to read more about the Gaussian mixed effects models + using "variance stabilising transformation (VST) can be applied to count data through DESeq2 or the voom transformation in limma voom."**

